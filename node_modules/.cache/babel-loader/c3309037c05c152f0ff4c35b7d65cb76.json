{"ast":null,"code":"export class Posts {\n  constructor() {\n    this.ws = void 0;\n    this.ws = asyncWebSocket('ws://127.0.0.1:3002/posts');\n  }\n\n  async getPosts() {\n    const ws = await this.ws; // просто ща вот мы отправили запрос, что хотим посты\n\n    ws.send(JSON.stringify({\n      action: 'get_posts'\n    })); // нам ответ придется ловить в другом месте, или делать(и что это значит?) так:\n    // это значит мы не сможем вернуть ответ тут же, надо немного переписат код, чтобы он стал .ммм\n    // ориентированным на события, зависимым от сервера\n    // а сейчас (через фетч) как бы наоборот, МЫ по своей инициативе спрашиваем сервер и ответ тут же получаем\n    // ниче не понятно пока\n    // по сути придется првератить весь этот код в обработчик on'message'ов)\n    // сделать колбеки, чтоб при получении новых данных App мог отреагировать\n    // КРЧ. Предлагаю тогда наоборот, не переделывать все на сокеты, а просто использовать их для обновления\n    // блин у нас кода оч мало по сути. это чет жесть. думала там 5 минут переписать. сервер же быстро писала\n    // тут посто логика сильно с ног на голову переворачивается \n    // давай просто получение нового сообщения пока запилим, и, если все будет понятно, то остальное перепишем\n    // та давай хть что-то уже..а то я уже запуталась в край\n\n    return new Promise(resolve => {\n      ws.onmessage = ev => resolve(ev.data);\n    }); // return fetch('http://127.0.0.1:3001/get_posts')\n  }\n\n  sendPost(post) {\n    return fetch(`http://127.0.0.1:3001/send_post?name=${post.name}&text=${post.text}`);\n  }\n\n} // давай для начала объясню, что я тут а\n\nfunction asyncWebSocket(url) {\n  return new Promise((resolve, reject) => {\n    const ws = new WebSocket(url);\n\n    ws.onopen = () => resolve(ws);\n  });\n}","map":{"version":3,"sources":["D:/programming/network.v1/cozy-space-client/src/Data.ts"],"names":["Posts","constructor","ws","asyncWebSocket","getPosts","send","JSON","stringify","action","Promise","resolve","onmessage","ev","data","sendPost","post","fetch","name","text","url","reject","WebSocket","onopen"],"mappings":"AAEA,OAAO,MAAMA,KAAN,CAAY;AAEjBC,EAAAA,WAAW,GAAG;AAAA,SADNC,EACM;AACZ,SAAKA,EAAL,GAAWC,cAAc,CAAC,2BAAD,CAAzB;AACD;;AAEa,QAARC,QAAQ,GAAG;AACf,UAAMF,EAAE,GAAG,MAAM,KAAKA,EAAtB,CADe,CAEf;;AACAA,IAAAA,EAAE,CAACG,IAAH,CAAQC,IAAI,CAACC,SAAL,CAAe;AAAEC,MAAAA,MAAM,EAAE;AAAV,KAAf,CAAR,EAHe,CAIf;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;;AACA,WAAO,IAAIC,OAAJ,CAAYC,OAAO,IAAI;AAC5BR,MAAAA,EAAE,CAACS,SAAH,GAAgBC,EAAD,IAAQF,OAAO,CAACE,EAAE,CAACC,IAAJ,CAA9B;AACD,KAFM,CAAP,CAjBe,CAoBf;AACD;;AACDC,EAAAA,QAAQ,CAACC,IAAD,EAAa;AACnB,WAAOC,KAAK,CAAE,wCAAuCD,IAAI,CAACE,IAAK,SAAQF,IAAI,CAACG,IAAK,EAArE,CAAZ;AACD;;AA9BgB,C,CAiCnB;;AACA,SAASf,cAAT,CAAwBgB,GAAxB,EAAyD;AACvD,SAAO,IAAIV,OAAJ,CAAY,CAACC,OAAD,EAAUU,MAAV,KAAqB;AACtC,UAAMlB,EAAE,GAAG,IAAImB,SAAJ,CAAcF,GAAd,CAAX;;AACAjB,IAAAA,EAAE,CAACoB,MAAH,GAAY,MAAMZ,OAAO,CAACR,EAAD,CAAzB;AACD,GAHM,CAAP;AAID","sourcesContent":["import { Post } from './types'\r\n\r\nexport class Posts {\r\n  private ws: Promise<WebSocket>\r\n  constructor() {\r\n    this.ws =  asyncWebSocket('ws://127.0.0.1:3002/posts')\r\n  }\r\n\r\n  async getPosts() {\r\n    const ws = await this.ws;\r\n    // просто ща вот мы отправили запрос, что хотим посты\r\n    ws.send(JSON.stringify({ action: 'get_posts' }))\r\n    // нам ответ придется ловить в другом месте, или делать(и что это значит?) так:\r\n    // это значит мы не сможем вернуть ответ тут же, надо немного переписат код, чтобы он стал .ммм\r\n    // ориентированным на события, зависимым от сервера\r\n    // а сейчас (через фетч) как бы наоборот, МЫ по своей инициативе спрашиваем сервер и ответ тут же получаем\r\n    // ниче не понятно пока\r\n    // по сути придется првератить весь этот код в обработчик on'message'ов)\r\n    // сделать колбеки, чтоб при получении новых данных App мог отреагировать\r\n\r\n    // КРЧ. Предлагаю тогда наоборот, не переделывать все на сокеты, а просто использовать их для обновления\r\n    // блин у нас кода оч мало по сути. это чет жесть. думала там 5 минут переписать. сервер же быстро писала\r\n    // тут посто логика сильно с ног на голову переворачивается \r\n    // давай просто получение нового сообщения пока запилим, и, если все будет понятно, то остальное перепишем\r\n    // та давай хть что-то уже..а то я уже запуталась в край\r\n    return new Promise(resolve => {\r\n      ws.onmessage = (ev) => resolve(ev.data)\r\n    })\r\n    // return fetch('http://127.0.0.1:3001/get_posts')\r\n  }\r\n  sendPost(post: Post) {\r\n    return fetch(`http://127.0.0.1:3001/send_post?name=${post.name}&text=${post.text}`)\r\n  }\r\n}\r\n\r\n// давай для начала объясню, что я тут а\r\nfunction asyncWebSocket(url: string): Promise<WebSocket> {\r\n  return new Promise((resolve, reject) => {\r\n    const ws = new WebSocket(url)\r\n    ws.onopen = () => resolve(ws)\r\n  })\r\n}\r\n"]},"metadata":{},"sourceType":"module"}