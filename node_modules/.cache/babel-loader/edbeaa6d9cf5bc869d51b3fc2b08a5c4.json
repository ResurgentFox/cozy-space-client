{"ast":null,"code":"export class Posts {\n  constructor() {\n    this.ws = void 0;\n    this.ws = asyncWebSocket('ws://127.0.0.1:3002/posts');\n  }\n\n  async getPosts() {\n    // нам ответ придется ловить в другом месте, или делать(и что это значит?) так:\n    // это значит мы не сможем вернуть ответ тут же, надо немного переписат код, чтобы он стал .ммм\n    // ориентированным на события, зависимым от сервера\n    // а сейчас (через фетч) как бы наоборот, МЫ по своей инициативе спрашиваем сервер и ответ тут же получаем\n    // ниче не понятно пока\n    // по сути придется првератить весь этот код в обработчик on'message'ов)\n    // сделать колбеки, чтоб при получении новых данных App мог отреагировать\n    // КРЧ. Предлагаю тогда наоборот, не переделывать все на сокеты, а просто использовать их для обновления\n    // блин у нас кода оч мало по сути. это чет жесть. думала там 5 минут переписать. сервер же быстро писала\n    // тут посто логика сильно с ног на голову переворачивается \n    // давай просто получение нового сообщения пока запилим, и, если все будет понятно, то остальное перепишем\n    // та давай хть что-то уже..а то я уже запуталась в край\n    // ты тут? да\n    //  ща я все верну, как было\n    return fetch('http://127.0.0.1:3001/get_posts');\n  }\n\n  sendPost(post) {\n    return fetch(`http://127.0.0.1:3001/send_post?name=${post.name}&text=${post.text}`);\n  }\n\n} // давай для начала объясню, что я тут написал\n// по сути смысл данной функции в том, чтобы создать вебсокет 1\n// 2 - добавить колбек, который выполнится, когда сокет откроется (будет готов)\n// 3 - вернуть результат в виде промиса, чтобы потом можно было дождаться готовности вебсокета\n// прост если не ждать, то ты видела, какая ошибка получается\n\nfunction asyncWebSocket(url) {\n  return new Promise((resolve, reject) => {\n    const ws = new WebSocket(url); // (1)\n\n    ws.onopen = () => resolve(ws); // (2 - 3)\n\n  });\n}","map":{"version":3,"sources":["D:/programming/network.v1/cozy-space-client/src/Data.ts"],"names":["Posts","constructor","ws","asyncWebSocket","getPosts","fetch","sendPost","post","name","text","url","Promise","resolve","reject","WebSocket","onopen"],"mappings":"AAEA,OAAO,MAAMA,KAAN,CAAY;AAEjBC,EAAAA,WAAW,GAAG;AAAA,SADNC,EACM;AACZ,SAAKA,EAAL,GAAWC,cAAc,CAAC,2BAAD,CAAzB;AACD;;AAEa,QAARC,QAAQ,GAAG;AAEf;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAOC,KAAK,CAAC,iCAAD,CAAZ;AACD;;AACDC,EAAAA,QAAQ,CAACC,IAAD,EAAa;AACnB,WAAOF,KAAK,CAAE,wCAAuCE,IAAI,CAACC,IAAK,SAAQD,IAAI,CAACE,IAAK,EAArE,CAAZ;AACD;;AA3BgB,C,CA8BnB;AACA;AACA;AACA;AACA;;AACA,SAASN,cAAT,CAAwBO,GAAxB,EAAyD;AACvD,SAAO,IAAIC,OAAJ,CAAY,CAACC,OAAD,EAAUC,MAAV,KAAqB;AACtC,UAAMX,EAAE,GAAG,IAAIY,SAAJ,CAAcJ,GAAd,CAAX,CADsC,CACR;;AAC9BR,IAAAA,EAAE,CAACa,MAAH,GAAY,MAAMH,OAAO,CAACV,EAAD,CAAzB,CAFsC,CAER;;AAC/B,GAHM,CAAP;AAID","sourcesContent":["import { Post } from './types'\r\n\r\nexport class Posts {\r\n  private ws: Promise<WebSocket>\r\n  constructor() {\r\n    this.ws =  asyncWebSocket('ws://127.0.0.1:3002/posts')\r\n  }\r\n\r\n  async getPosts() {\r\n\r\n    // нам ответ придется ловить в другом месте, или делать(и что это значит?) так:\r\n    // это значит мы не сможем вернуть ответ тут же, надо немного переписат код, чтобы он стал .ммм\r\n    // ориентированным на события, зависимым от сервера\r\n    // а сейчас (через фетч) как бы наоборот, МЫ по своей инициативе спрашиваем сервер и ответ тут же получаем\r\n    // ниче не понятно пока\r\n    // по сути придется првератить весь этот код в обработчик on'message'ов)\r\n    // сделать колбеки, чтоб при получении новых данных App мог отреагировать\r\n\r\n    // КРЧ. Предлагаю тогда наоборот, не переделывать все на сокеты, а просто использовать их для обновления\r\n    // блин у нас кода оч мало по сути. это чет жесть. думала там 5 минут переписать. сервер же быстро писала\r\n    // тут посто логика сильно с ног на голову переворачивается \r\n    // давай просто получение нового сообщения пока запилим, и, если все будет понятно, то остальное перепишем\r\n    // та давай хть что-то уже..а то я уже запуталась в край\r\n    // ты тут? да\r\n    //  ща я все верну, как было\r\n    return fetch('http://127.0.0.1:3001/get_posts')\r\n  }\r\n  sendPost(post: Post) {\r\n    return fetch(`http://127.0.0.1:3001/send_post?name=${post.name}&text=${post.text}`)\r\n  }\r\n}\r\n\r\n// давай для начала объясню, что я тут написал\r\n// по сути смысл данной функции в том, чтобы создать вебсокет 1\r\n// 2 - добавить колбек, который выполнится, когда сокет откроется (будет готов)\r\n// 3 - вернуть результат в виде промиса, чтобы потом можно было дождаться готовности вебсокета\r\n// прост если не ждать, то ты видела, какая ошибка получается\r\nfunction asyncWebSocket(url: string): Promise<WebSocket> {\r\n  return new Promise((resolve, reject) => {\r\n    const ws = new WebSocket(url) // (1)\r\n    ws.onopen = () => resolve(ws) // (2 - 3)\r\n  })\r\n}\r\n"]},"metadata":{},"sourceType":"module"}